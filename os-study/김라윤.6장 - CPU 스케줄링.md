## 기계어 명령
CPU 내에서 수행되는 명령을 말한다.

### Add 명령
- CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령
	
    - 명령의 수행 속도가 매우 빠르다
### 메모리 접근을 필요로 하는 명령

- `Load 명령`
	
    - 메모리에 있는 데이터를 CPU로 읽어들이는 명령
- `Store 명령`
	
    - CPU에서 계산된 결괏값을 메모리에 저장하는 명령

### 입출력을 동반하는 명령

- 키보드 입력을 받는다든지 컴퓨터에서 처리된 결과를 화면에 출력 등 
	
    - CPU나 메모리 접근 명령에 비해 오랜 시간이 소요된다.

#### 일반명령
CPU 내에서 일어나는 명령, 메모리를 접근하는 명령 
- `특권명령` : 모든 입출력 명령

#### CPU 버스트_burst_
사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계 
#### I/O 버스트
I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계

- 각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 균일하지 않다.
![](https://velog.velcdn.com/images/rayung999/post/74353823-0cac-4950-adc8-9c498b94b1df/image.png)


#### I/O 바운드 프로세스_I/O bound process_ 
- I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
#### CPU 바운드 프로세스_CPU bound process_ 
- I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스
	
![](https://velog.velcdn.com/images/rayung999/post/c188a6f5-3701-426d-87ae-4e52c7926e75/image.png)

> CPU 스케줄링은 이와 같이 CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 필요하다.
    
- - -

## 1. CPU 스케줄러
`CPU 스케줄러`는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다.
### CPU 스케줄링이 필요한 대표적인 상황
- 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 `봉쇄` _blocked_ 상태로 바뀌는 경우

- 실행 상태에 있던 프로세스가 `타이머 인터럽트` 발생에 의해 준비 상태로 바뀌는 경우

- I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우

- CPU에서 실행 상태에 있는 프로세스가 종료되는 경우

### CPU 스케줄링 방식 
#### 비선점형_monpreemptive_ 
- 1, 4 CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법 
#### 선점형_preemptive_ 
- 2, 3 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법

- - -

## 2. 디스패처
새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드

### 디스패치 지연시간_dispatch latency_
디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간

## 3. 스케줄링의 성능 평가
스케줄링 기법의 성능을 평가하기 위해 여러 지표들이 사용

### 시스템 관점의 지표
#### CPU 이용률_CPU utilization_ 
- 전체 시간 중에서 CPU가 일을 한 시간의 비율을 나타낸다.

### 처리량_throughput_ 
- 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지 (CPU 버스트를 완료한 프로세스의 개수)를 나타낸다.

### 사용자 관점의 지표
#### 소요시간_turnaround time_ 
- 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간, 즉 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합

#### 대기시간_waiting time_ 
- CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합

#### 응답시간_response time_ 
- 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간

- - -

## 4. 스케줄링 알고리즘
### 1) 선입선출 스케줄링 _First-Come First-Served: FCFS_ 
프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식
#### 콘보이 현상_Convoy effect_ 
- CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상이며, `FCFS 스케줄링`의 대표적인 단점에 해당된다.

### 2) 최단작업 우선 스케줄링 _Shortest-Job First: SJF_
알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식

- `SJF 스케줄링 알고리즘`은 평균 대기시간을 가장 짧게 하는 `최적 알고리즘`_optimal algorithm_으로 알려져 있다.

#### 비선점형 방식

- CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식
#### 선점형 방식

- 준비 큐에서 CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했다 하더라도, CPU 버스트가 더 짧은 프로세스가 도착할 경우 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식
- `SJF`의 `선점형 구현 방식`을 `SRTF_Shortest Remaining Time First_`라고도 부른다.
### 3) 우선순위 스케줄링 _priority scheduling_
준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식

- `우선순위`는 `우선순위값`_priority number_을 통해 표시하며 `우선순위값`이 작을수록 높은 `우선순위`를 가지는 것으로 가정한다.

- `우선순위 스케줄링`도 `비선점형`과 `선점형` 방식으로 각각 구현할 수 있다.

> 우선순위 스케줄링 방식에서의 문제점 중 하나는 기아 현상이 발생할 수 있다는 점이다. => 우선순위가 높은 프로세스가 계속 도착하는 상황에서 우선순위가 낮은 프로세스는 CPU를 얻지 못한 채 계속 기다려야 할 수 있기 때문이다.

#### 노화_aging_ 기법
- 문제점을 해결하기 위해 `노화 기법`을 사용할 수 있다. 
- 기다리는 시간이 길어지면 우선순위를 조금씩 높여, 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 해주는 방법

### 4) 라운드 로빈 스케줄링 _Round Robin Scheduling_
시분할 시스템의 성질을 가장 잘 활용한 새로운 의미의 스케줄링 방식

- 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한 
- 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수
- 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당한다. 
- 회수당한 프로세스는 준비 큐의 제일 뒤에 가서 줄을 서 차례를 기다린다. 
- `할당시간`_time quantum_ : 각 프로세스마다 한 번에 CPU를 연속적으로 사용할 수 있는 최대시간

### 5) 멀티레벨 큐 _multi-level queue_
준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법이다. 
- 즉 프로세스들이 CPU를 기다리기 위해 한 줄로 서는 것이 아니라 여러 줄로 서는 것
![](https://velog.velcdn.com/images/rayung999/post/5f167393-0f1a-450c-9990-c59409407f48/image.png)


### 6) 멀티레벨 피드백 큐 _Multilevel Feedback Queue_
CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 `멀티레벨 큐`와 동일 하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능하다는 점이 다르다.
![](https://velog.velcdn.com/images/rayung999/post/30c251b9-cdb1-4bfc-9793-97d549239154/image.png)


### 7) 다중처리기 스케줄링
CPU가 여러 개인 시스템을 `다중처리기 시스템`_multi-processor system_이라고 부른다.

> 여러 줄로 줄 세우기를 하는 경우 일부 CPU에 작업이 편중되는 현상이 발생할 수 있다.
- `다중처리기 스케줄링`_multiple-processor scheduling_에서는 이와 같은 현상을 방지하기 위해 
각 CPU별 부하가 적절히 분산되도록 하는 `부하균형`_load balancing_ 메커니즘을 필요로 한다.

#### 다중처리기 스케줄링의 방식

- `대칭형 다중처리`_symmetric multi-processing_ : 각 CPU가 각자 알아서 스케줄링을 결정하는 방식

- `비대칭형 다중처리`_asymmetric multiprogrammig_ 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고 나머지 CPU는 거기에 따라 움직이는 방식
### 8) 실시간 스케줄링 _real-time system_
각 작업마다 주어진 데드라인이 있어 정해진 데드라인 안에 반드시 작업을 처리해야 한다.
#### 경성 실시간 시스템_hard real-time system_ 
- 정해진 시간 안에 반드시 작업이 완료되도록 스케줄링해야 한다.

#### 연성 실시간 시스템_soft real-time system_ 
데드라인이 존재하기는 하지만 데드라인을 지키지 못했다고 해서 위험한 상황이 발생하지는 않는다.

> 실시간 환경에서는 먼저 온 요청을 먼저 처리하기보다는 `데드라인`이 얼마 남지 않은 요청을 먼저 처리하는 `EDF`_Earlist Deadline First_ 스케줄링을 널리 사용하게 된다.

- - -

## 5. 스케줄링 알고리즘의 평가
### 스케줄링 알고리즘의 성능을 평가하는 방법
#### 큐잉모델_que-ueing model_ 
주로 이론가들이 수행하는 방식
- 확률분포를 통해 프로세스들이 도착률과 CPU의 처리율을 입력값으로 주면 복잡한 수학적 계산을 통해 각종 `성능지표`_performance index_인 CPU의 처리량, 프로세스의 평균 대기시간 등을 구하게 된다.

#### 구현 및 실측_implementation & measurement_ 
이론가와 정반대인 구현가들이 수행할 수 있는 방식
- 운영체제 커널의 소스 코드 중 CPU 스케줄링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치하는 과정을 필요로 한다. 그런 다음 동일한 프로그램을 원래 커널과 CPU 스케줄러를 수정한 커널에서 수행시켜보고 실행시간을 측정하여 알고리즘의 서능을 평가한다.

#### 시뮬레이션_simulation_ 
실제 시스템에 구현해 수행시커보는 것이 아니라 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지를 확인하는 방법
- 입력값은 가상으로 생성할 수도 있고 실제 시스템에서의 CPU 요청 내역을 추출해 사용할 수도 있다. 
	
    - `트레이스`_trace_ : 실제 시스템에서 추출한 입력값
    