운영체제는 보통 모든 프로그램들에 공평하게 같은 크기의 메모리를 할당하기보다는 몇몇 프로그램들에게 집중적으로 메모리를 할당한 후, 시간이 흐르면 이들로부터 메모리를 회수에서 다른 프로그램들에게 다시 집중적으로 메모리를 할당하는 방식을 채택한다.
- 이와 같은 방식을 사용하는 이유는 프로세스의 빠른 수행을 위해 프로그램마다 최소한 확보해야하는 메모리의 크기가 존재하기 때문이다.
### 가상메모리 (virtual memory)
프로세스 입장에서 자신만의 메모리라고 생각하는 0번지부터 시작디는 메모리 공간

#### 가상메모리의 기법
`요구 페이징`과 `요구 세그먼테이션`으로 나뉘는데 대부분은 `요구 페이징 기법`을 많이 사용한다.

## 1. 요구 페이징
`요구 페이징`이란 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라 당장 사용될 페이지만을 올리는 방식을 말한다.
- 프로세스는 페이지 단위로 나누고 메모리는 프레임 단위로 나눠서 실행에 필요한 페이지만 메모리에 적재한다.
	
    - 메모리 사용량이 감소하고, 프로세스 전체를 메모리에 올리는 데 소요되는 입출력 오버헤드도 줄어든다.
    
- 필요한 페이지만 메모리에 올리므로 프로세스가 필요로 하는 메모리가 물리적 메모리보다 커도 실행을 할 수 있다.

### 유효-무효 비트 (valid-invalid bit)
- 프로세스가 실행되지 전에는 모든 페이지의 비트가 무효값으로 초기화.
- 특정 페이지가 참조되어 메모리에 올라가면 유효로 세팅.
- 메모리에 적재되어 있던 페이지가 스왑 영역으로 쫒겨나면 다시 무효가 됨.

> `유효-무효 비트`의 값이 무효인 경우는 페이지가 현재 메모리에 없는 경우를 의미할 수도 있지만 경우에 따라서는 그 페이지가 속한 주소 영역을 프로세스가 사용하지 않는 경우도 있다.
- `페이지 부재` : 페이지 참조 시 `유효-무효 비트`가 무효인 경우

### 1) 요구 페이징의 페이지 부재 처리
- CPU가 무효 페이지에 접근
- 주소 변환 담당 하드웨어 MMU가 `페이지 부재 트랩`(page fault trap)을 발생시킴
- CPU의 제어권이 커널모드로 전환
- 운영체제의 `페이지 부재 처리루틴`(page fault handler)이 호출됨
- 해당 페이지에 대한 접근이 적법한지 운영체제가 검사
- 사용되지 않는 주소 혹은 접근 권한 위반(protection violation)의 경우 해당 프로세스 종료
- 적법한 경우 물리적 메모리에 비어있는 프레임을 할당받아 페이지를 읽음
- 비어있는 페이지가 없는 경우 메모리에 올라와 있는 페이지 중 하나를 스왑 아웃 시킴
- 요청된 페이지를 디스크로부터 메모리로 적재할 때까지  오랜 시간이 걸리므로 그동안 페이지 부재를 발생시킨 프로세스는 봉쇄 상태
- 봉쇄 상태 들어가기 전 CPU 레지스터 상태 및 프로그램 카운터값을 프로세스 제어블록에 저장
- 디스크 입출력이 완료되면 인터럽트 발생
- 페이지 테이블에서 해당 페이지의 `유효-무효 비트`를 유효로 설정
- 봉쇄 상태였던 프로세스는 준비 큐로 이동
- 준비 큐에 있다가 CPU를 할당받게 되면 중단되었던 명령부터 실행

#### 2) 요구 페이징의 성능
`요구 페이징 기법`의 성능에 가장 큰 영향을 미치는 요소는 페이지 부재의 발생 빈도이다.
- 페이지 부재시 디스크로부터 페이지를 읽는데 막대한 오버해드가 발생
- 페이지 부재가 최대한 적게 발생해야 성능을 올릴 수 있음

	
    - 요구 페이지 성능 계산식
    **페이지 부재 발생 비율** (page fault rate) 
    P = 0 : 페이지 부재가 한 번도 일어나지 않은 경우
    P = 1 : 모든 참조 요청에서 페이지 부재가 발생한 경우
    ![](https://velog.velcdn.com/images/rayung999/post/80200d3d-f0d6-4992-ac89-9dc479c3008e/image.png)
	
    
## 2. 페이지 교체
![](https://velog.velcdn.com/images/rayung999/post/71354b16-f21c-45f6-bb76-1a406629da30/image.png)

`페이지 교체 알고리즘` : 페이지 부재시 빈 페이지마저 없어서 어떤 페이지를 스왑 아웃 시킬지 결정하는 알고리즘

### 페이지 교체 알고리즘의 성능
- 주어진 `페이지 참조열`(Page Reference String)에 대해 페이지 부재율을 계산
	
    - `페이지 참조열` : 참조가 요구되는 페이지들의 나열
    
### 페이지 교체 알고리즘 종류
#### 1) 최적  페이지 교체
- 가장 먼 미래에 참조될 페이지를 쫒아냄
- 이 알고리즘은 미래에 어떤 페이지가 어떠한 순서로 참조될 지 미리 알고 있다는 전제하에 알고리즘을 운영하므로 실제 시스템에서 온라인으로 사용할 수 있는 알고리즘은 아니다. (`오프라인 알고리즘`이라고 부름) 
![](https://velog.velcdn.com/images/rayung999/post/042c5434-44b1-4fa4-a70f-8d7575b0a583/image.png)

#### 2) 선입선출 알고리즘
- `선입선출 알고리즘`은 페이지 교체 시 먼저 참조되었던 메모리부터 방출
- 향후 참조될 가능성을 고려하지 않고 성능이 안좋음
- 프레임이 늘어난다고 페이지 부재가 줄어들지 않을 수도 있고 늘어날 수도 있음 (이 현상을 FIFO의 이상현상이라고 함)
![](https://velog.velcdn.com/images/rayung999/post/98f57b76-0ac2-4623-8d0b-1aaf32881caa/image.png)

#### 3) LRU 알고리즘
최근의 참조된 페이지가 가까운 미래에 또 참조될 가능성이 크다는 전제를 바탕으로 한 알고리즘
- 가장 오래전에 참조된 페이지를 쫓아냄
![](https://velog.velcdn.com/images/rayung999/post/ed71a932-b1cb-489f-ba45-f589bc0b0d2d/image.png)

#### 4) LFU 알고리즘
- `참조횟수`(Reference Count)가 적었던 페이지부터 방출
- 참조횟수가 같은 경우 임의로 하나를 선정하는데 이때는 보통 오래전에 참조된 페이지를 쫓아내도록 함
- 참조횟수를 계산하는 방식 => Incache-LFU, Perfect-LFU
	
    
   - `Incache-LFU`
   		
        - 방출됐다가 다시 들어온 경우 참조 횟수가 1로 초기화
        
   - `Perfect-LFU`
   		
        - 쫒겨나도 참조 횟수가 초기화 되지 않음
        - 오래 기억하고 있어야 해서 오버헤드가 더 큼
        
> `LRU`와 `LFU`의 장단점
 - `LRU`는 과거의 기록을 반영하지 못하지만 오버헤드가 작음
- `LFU`는 과거의 기록을 반영하지만 최신의 일어난 변화에 반응이 덜하고 LRU보다 구현이 복잡함

- 둘의 장단점을 극단적으로 보여주는 예
![](https://velog.velcdn.com/images/rayung999/post/8ba350e3-0b3f-44b3-b563-cd258df3dd82/image.png)

#### 5) 클럭 알고리즘
- 위의 알고리즘에서 페이지 프레임이 선형으로 배치된것과 달리 원형 배치되어 있음
- 처음 페이지가 참조될 때 참조비트를 1로 설정
- 페이지 교체시 교체 대상을 선정할 때 포인터가 프레임의 참조비트를 원형으로 돌면서 검색함
- 포인터가 참조비트에 도착했을 때 1이면 0으로 만드로 0이면 해당 프레임의 페이지를 스왑 아웃시킴
- 포인터가 참조된 이후로 한바퀴는 프레임에 살아 남아 있을 수 있어서 `2차 기회 알고리즘`(Second chance algorithm)이라고도 불림. 
	
    - 혹은 NUR(Not Used Recentrly), NRU(Not Recently Used)로 불림

## 3. 페이지 프레임의 할당
각 프로세스에 페이지 프레임을 얼마만큼 할당할 것인지를 결정해야 한다. 
- 너무 많이 할당하면 메모리에 동시에 올라간 프로세스가 적어서 일하지 않는 CPU가 생겨서 CPU의 활용도가 떨어짐
- 너무 조금씩 할당하면 프로세스가 최소로 필요로 하는 프레임마저도 충족을 못시킴
	
    - 예를 들어 프로세스가 반복문을 돌릴 경우 반복문에 필요한 코드는 계속 메모리에 올라와 있어야 하는데 그 중 하나라도 메모리에 없는 경우 페이지의 매 반복마다 일어나게 된다.
    
## 4. 전역교체와 지역교체
교체할 페이지를 선정할 때, 교체 대상이 될 프레임의 범위를 어떻게 할지에 따라 교체 방법을 `전역교체`(global replacement)와 `지역교체`(local replacement)로 구분할 수 있다. 
- `전역교체` : 프로세스마다 페이지 프레임을 미리 할당하는 것이 아니라 전체 메모리를 각 프로세스가 공유해서 사용하고 교체 알고리즘에 근거해서 할당되는 메모리 양이 가변적으로 변하는 방법

- `지역교체` : 프로세스마다 페이지 프레임을 미리 할당하는 것을 전제로 현재 수행중인 프로세스에게 할당된 프레임 내에서만 교체 대상을 선정할 수 있는 방법

## 5. 스레싱
![](https://velog.velcdn.com/images/rayung999/post/403516b4-24c3-418d-b069-11822e2ff37a/image.png)

- 동시에 실행되는 프로세스가 많아질수록(MPD가 커질수록) 초반에는 CPU 이용률이 올라감
	
    - 메모리에 동시에 올라가 있는 프로세스의 수를 `다중 프로그래밍의 정도`(Multi-Programming Degree: MPD)라고 부른다.
    - 프로세스가 적으면 해당 CPU사용보다 I/O 작업이 많아서 CPU사용률이 적음
    
- 프로세스가 많아질수록 프로세스가 I/O작업이어도 준비큐에 있는 다른 프로세스에게 CPU를 할당해서 CPU가 놀고 있는 시간이 적어짐
- 프로세스가 특정 숫자 이상으로 많아지면 한 프로세스에게 할당된 페이지가 너무 적어져서 아주 조금을 돌리기 위해서도 페이지 부재가 발생함
	
    - `페이지 부재`가 발생한 순간, 디스크에서 해당 페이지를 불러오는 I/O작업이 일어나고 프로세스는 봉쇄상태가 되어서 다른 프로세스에게 CPU가 이양됨. 
    
  
    - 할당된 페이지가 작아지면 작아질수록 거의 모든 프로세스는 CPU작업은 못하고 페이지를 데려오는 I/O작업만 일어나서 CPU는 아무일을 못해서 이용률이 최악이 됨

    - 아이러니하게 CPU 이용률이 줄어들면 운영체제는 동시의 돌아가는 프로세스가 적다고 판단해서 프로세스를 더 많이 메모리에 올리려고 함.
    

- 이렇게 CPU사용률이 급격하게 줄어드는 것을 `스레싱`(thrashing)이라고 함

### 1) 워킹셋 알고리즘
- `지역성 집합`(locality set) 
	
    - 프로세스는 특정 시간동안 일정 장소만을 집중적으로 참조하는데 이때 집중적으로 참조되는 해당 페이지들의 집합을 말한다.

- `워킹셋` (working set) 알고리즘
	
    - 지역성 집합에 기반하여 프로세스가 일정 시간동안 원활하게 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합을 말한다.
    
    - 워킹셋에서는 프로세스의 워킹셋 전체가 메모리에 올라와 있어야 수행되고 그렇지 않을 경우 모든 프레임을 반납한 후 스왑 아웃 시킨다.
    - MPD를 조절하고 스레싱을 방지한다.
    
![](https://velog.velcdn.com/images/rayung999/post/7b3d3a50-8cbc-4d68-936b-263764d67684/image.png)

![](https://velog.velcdn.com/images/rayung999/post/8c15481b-4adc-4d8e-aade-88e35c87d894/image.png)

### 2) 페이지 부재 빈도 알고리즘
`페이지 부재 빈도`(page Fault Frequency: PFF) 알고리즘은 프로세스의 페이지 부재율을 주기적으로 조사하고 이 값에 근거해서 각 프로세스에 할당할 메모리 양을 동적으로 조절한다.
- 어떤 프로세스의 페이지 부재율이 시스템에서 미리 정해놓은 `상한값`을 넘게 되면 이 프로세스에 할당된 프레임 수가 부족하다고 판단하여 이 프로세스에게 프레임을 추가로 더 할당한다. 
	
    - 이떄 추가로 할당할 빈 프레임이 없다면 일부 프로세스를 스왑 아웃시켜 메모리에 올라가 있는 프로세스의 수를 조절. 
    
- 반면 프로세스의 페이지 부재율이 `하한값` 이하로 떨어지면 이 프로세스에게 필요 이상으로 많은 프레임이 할당된것으로 간주해 할당된 프레임의 수를 줄인다. 
![](https://velog.velcdn.com/images/rayung999/post/7b1a78a1-d32c-43d7-a48d-0de0356d9aa3/image.png)

> 이런 방식으로 메모리 내에 존재하는 모든 프로세스에 필요한 프레임을 다 할당한 후에도 프레임이 남는 경우 스왑 아웃되었던 프로세스에게 프레임을 할당함으로써 MPD를 높인다. 
이러한 원리로 MPD를 조절하면서 CPU 이용률을 높이는 동시에 스레싱을 방지한다.
