## 6. DMA 
- 메모리 접근 연산이 `CPU`에 의해서만 이루어질 경우 입출력 장치가 메모리 접근을 원할 때마다 `인터럽트`에 의해 CPU의 엄무가 방해를 받게 되어 `CPU사용의 효율성`이 떨어지는 문제점이 발생한다.

> `DMA` : CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 `인터럽트` 당하는 것을 막아 주는 역할을 한다.
	
- 위와 같은 문제 때문에 CPU 이외의 메모리 접근 가능한 장치를 하나 더 두는데 그것을 `DMA`라고 한다.
    
![](https://velog.velcdn.com/images/rayung999/post/0c6676b3-11e7-4d04-b997-548293f3205d/image.png)

- - - 

## 7. 저장장치의 구조
컴퓨터 시스템을 구성하는 저장장치는 `주기억장치`와 `보조기억장치`로 나눌 수 있다.
- `주기억장치` :
	
    - 보통 메모리라고 부르며 전원이 나가면 저장되었던 내용이 모두 사라져 버리는 `휘발성`의 `RAM`을 매체로 사용되는 경우가 대부분.
    

- `보조기억장치` :
	
    - 전원이 나가도 저장된 내용을 기억할 수 있는 `비휘발성`의 `마그네틱 디스크`를 주로 사용한다.
  
    - `파일 시스템용` _file system_
    	- 전원이 나가도 유지해야 할 정보가 있으면 그것을 `파일 형태`로 보조기억장치에 저장.
 
    -  `스왑 영역` _swap area_
    	- 메모리는 크기가 한정되고, 가격이 상대적으로 비싼데다가 용량이 적은 경우가 대부분이라, 운영체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 `스왑 영역`에 내려놓게 된다.
        - 위와 같이 디스크에 내려놓는 일을 `스왑 아웃` _swap out_ 이라 한다.

![](https://velog.velcdn.com/images/rayung999/post/f4efd3f8-ef13-40b0-8500-b1fd186d3813/image.png)
- 여러 개의 마그네틱 원판들이 있고 `암` _arm_ 이 이동하며 원판에 저장된 데이터를 읽고 쓰는 방식으로 동작.
- 디스크 원판의 표면은 `트랙` _track_ 으로 나뉘고, 각 트랙은 `섹터` _sector_ 로 나뉜다.

- - - 

## 8. 저장장치의 계층 구조
컴퓨터 시스템을 구성하는 저장장치는 빠른 저장장치부터 느린 저장장치까지 `단계적인 계층 구조`로 이루어진다.
![](https://velog.velcdn.com/images/rayung999/post/959fdc67-8c55-4af7-bfd0-66cfe91f60d6/image.png)
![](https://velog.velcdn.com/images/rayung999/post/b235a166-b5ca-416a-b318-6aa07bb98b3d/image.png)

- 상위 저장장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량은 상대적으로 적다.

- 하지만 당장 필요한 정보마을 선별적으로 저장하면 하위에 있는 큰 용량의 저장장치를 가지고 있는 것과 비슷한 성능 효과를 낼 수 있다.

- - -

## 9. 하드웨어의 보안
하드웨어적인 보안을 유지하기 위해서 
운영체제는 기본적으로 `커널모드` 와 `사용자모드` 이렇게 두 가지를 지원한다.

- `커널모드` _kernel mode_ , _system mode_
	
    - 운영체제가 `CPU의 제어권`을 가지고 윤영체제 코드를 실행하는 모드.
    - 이 모드에서는 `모든 종류의 명령`을 다 실행할 수 있다.
    
- `사용자모드` _user mode_
	
    - 일반 사용자 프로그램이 실행되며 `제한적인 명령`만 수행할 수 있다.
    
> 시스템에 중요한 영향을 미치는 연산은 `커널모드에서만 실행 가능`하도록 함으로써 하드웨어의 `보안을 유지`하는 것.


### 모드비트 _mode bit_
- 컴퓨터 시스템은 CPU 내부에 `모드비트`를 두어 사용자 프로그램을 감시하게 된다.

- `모드비트가 0`으로 세팅되어 있으면 `커널모드`로서 `모든 명령`을 수행할 수 있다.
- `모드비트가 1`로 세팅되어 있으면 `사용자모드`로서 `제한된 명령`만을 수행할 수 있다.
	
   > 1. CPU는 보안과 관련된 명령을 수행하기 전 `모드비트`를 조사
    2. 그 값이 `0으로 세팅된 경우`에만 그 명령을 수행
    3. 운영체제가 `CPU`를 점유해 자신의 코드를 수행
    4. 모드비트를 다시 `1로 세팅`
    5. 사용자 프로그램에게 `CPU의 제어권`을 넘김
    
![](https://velog.velcdn.com/images/rayung999/post/bf8b7f8d-e819-4fd0-a74f-8899100180a6/image.png)

- - -

## 10. 메모리 보안
여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문에 `메모리 보안`도 필요하다.
- `인터럽트 벡터`와 `인터럽트 처리루틴`이 있는 곳은 각별한 보안이 필요.
	
    - 사용자 프로그램이 `인터럽트 처리루틴`을 접근하거나 변경할 수 있을 경우 운영체제만 수행할 수 있는 `특권명령`을 보안성이 침해되는 이상한 명령으로 변형할 수 있기 떄문.
    	
        - 이에 해결방안으로 `기준 레지스터`와 `한계 레지스터`가 있다.

- `기준 레지스터` _base register_
	
    - 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리상의 가장 작은 주소를 보관하고 있다.
    
- `한계 레지스터` _limit register_
	
    - 그 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관하고 있다.
    
![](https://velog.velcdn.com/images/rayung999/post/dadfb23a-0f10-4009-8be0-9dacb8f10c42/image.png)

- - -

## 11. CPU 보호
CPU는 컴퓨터 시스템 내에 하나밖에 존재하지 않기 때문에 특정 프로그램이 `CPU를 독점`해 부적절한 방법으로 CPU의 사용 권한을 독점하고 있다면 다른 프로그램 및 운영체제가 CPU를 빼앗을 방법이 없게 된다.

- CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 운영체제는 `타이머`라는 하드웨어를 사용한다.
	
### 타이머 _timer_
- `타이머`는 정해진 시간이 지나면 `인터럽트`를 발생시켜 운영체제가 `CPU의 제어권`을 획득할 수 있도록 하는 역할을 수행한다.
	
    - `타이머`에 의해 발생되는 `인터럽트 처리루틴`의 역할
    	
        - 다른 프로그램으로부터 `CPU 제어권`을 빼앗는다.
        - 다른 프로그램에게 `CPU를 이양`한다.
        - 타이머는 `일정한 시간단위`로 세팅 가능
        - 매 `클럭 틱` _clock tick_ 때마다 1씩 감소.
        - 타이머가 0이 되는 순간 `인터럽트` 발생
   
> `타이머`의 값을 세팅하는 명령 = `로드 타이머` _load timer_ 
    
- - - 

## 12. 시스템 콜을 이용한 입출력 수행
- 사용자 프로그램이 디스크의 파일에 데이터를 쓰거나 디스크의 파일로부터 데이터를 읽어오는 행위, 키보드로부터 입력을 받거나 수행 결과를 화면의 출력하는 행위 등은 모두 `특권명령`인 `입출력 명령`에 해당
	
    - `특권명령`은 사용자 프로그램이 직접 수행할 수 없다. 
    - 하여, 운영체제에게 `시스템 콜`이라는 서비스 대행 요청을 하여 입출력을 수행한다. 

- `시스템 콜`은 일종의 `소프트웨어적인 인터럽트`로서 사용자 프로그램이 `시스템 콜`을 할 경우 `트랩`이 발생해 `CPU의 제어권`이 운영체제로 넘어가게 된다.
	
    > 1. `시스템 콜`이 '디스크 `입출력 요청`이었다' 할 떄,
    2. 디스크 컨트롤러에게 `입출력 요청`을 수행하도록 명령
    3. 디스크 컨트롤러가 `입출력 수행` 완료
    4. CPU 에게 `인터럽트를 발생`시켜 입출력이 완료되었음을 알림
    5. 해당 프로그램이 다시 `CPU를 할당`받음