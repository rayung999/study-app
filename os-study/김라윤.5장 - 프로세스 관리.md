## 1. 프로세스의 개념
`프로세스`_process_ : 실행 중인 프로그램 _program in execution_

- `프로세스의 문맥` : 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미
	
    - 그 프로세스의 `주소 공간`(코드,데이터,스택 상태)을 비롯해 `레지스터`에 어떤 값을 가지고 있었나.
    - `시스템 콜` 등을 통해 `커널`에서 수행한 일의 상태
    - 그 프로세스에 관해 `커널`이 관리하고 있는 `각종 정보`를 포함한다.
    
#### 프로세스 문맥의 세 가지 분류
1. `하드웨어 문맥` : CPU의 수행 상태를 나타내는 것으로 프로그램 카운터값과 각종 레지스터에 저장하고 있는 값들
2. `프로세스의 주소공간` : 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소 공간을 가지고 있다.
2. `커널상의 문맥` : 프로새스 관리를 위한 자료구조 (PCB, 커널스택) 를 유지하고, 이 또한 프로세스의 문맥을 구성하는 중요한 요소가 된다.
    
![](https://velog.velcdn.com/images/rayung999/post/f9834f58-8da7-400a-b65f-99ec7673a9d1/image.png)

- - -

## 2. 프로세스의 상태
프로세스의 상태는 실행, 준비, 봉쇄의 세 가지로 구분할 수 있다.

### 실행 _running_
- 실행 상태는 프로세스가 CPU를 보유하고, 기게어 명령을 실행하고 있는 상태를 가리킨다.

### 준비 _ready_
- 준비 상태는 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태를 가리킨다.

### 봉쇄 _blocked,wait,sleep_
- 봉쇄 상태는 CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태를 말한다. 
- 봉쇄 상태의 예로는 프로세스가 요청한 입출력 작업이 진행 중인 경우를 들 수 있다.

![](https://velog.velcdn.com/images/rayung999/post/d1a7b06a-fe71-4267-8c74-0f678c488fed/image.png)
> 이와 같이 프로세스의 상태를 구분하는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위해서이다.


<br>

또한 프로세스가 생성 중이거나 종료 중인 일시적 상태를 각각 시작상태, 완료상태라고 부른다.

### 시작 _new_ 상태
- 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되어 있지만 아직 메모리 획득을 승인받지 못한 상태
### 완료 _terminated_ 상태
- 프로세스가 종료되었으나 운영체제가 그 프로세스와 고나련된 자료구조를 완전히 정리하지 못한 상태

> 하나의 프로세스는 항상 앞서 말한 설명한 상태 중의 어느 한 상태에 머물러 있게 된다. 그리고 그 상태는 시간이 흐름에 따라 변하게 된다.

### 문맥 교환 _context switch_
- 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정

### CPU 디스패치 _dispatch_
- 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정

- - -

## 3. 프로세스 제어블록
운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조

### PCB의 구성 요소

- `프로세스의 상태` _process state_ : CPU를 `할당 여부`를 결정하기 위해 필요

- `프로그램 카운터` _program counter_의 값 : 다음에 수행할 `명령`의 위치
- `CPU 레지스터` _CPU register_ 의 값 : CPU 연산을 위해 현 시점 `레지스터`에 어떤 값을 저장하고 있는지
- `CPU 스케줄링 정보` _CPU scheduling information_ : 프로세스의 `CPU스케줄링`을 위해 필요한 정보
- `메모리 관리 정보` _memory management information_ : 프로세스의 `메모리 관리`를 위해 필요한 정보
- `자원 사용 정보` _accounting information_ : 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용
- `입출력 상태 정보` _I/O information_ : 프로세스의 `입출력` 관련 상태 정보

![](https://velog.velcdn.com/images/rayung999/post/0daf657d-331c-4c6b-8ce8-3b4885e3f95c/image.png)

- - -

## 4. 문맥교환 _context switch_
하나의 사용자 프로세스로부터 다른 사용자 프로세스로 cpu의 제어권이 이양되는 과정
![](https://velog.velcdn.com/images/rayung999/post/911274c7-ba19-46cf-85b4-becfbee66007/image.png)
- CPU가 한 프로세스에서 다른 프로세스로 넘겨주는 과정
- 문맥교환 과정에서 운영체제는 각 PCB에 프로그램 상태를 저장하고 불러오는 작업을 수행

#### 문맥교환이 아닌 경우
- `사용자 프로세스A` -> `ISR or System call 함수` -> `사용자 프로세스 A`(프로세스가 동일하다)
#### 문맥교환인 경우
- `사용자 프로세스A` -> `ISR or System call 함수` -> `사용자 프로세스 B`(프로세스 변경)

<br> 

`ISR` _Interrupt Service Routine_ : 인터럽트 접수에 의해 발생되는 인터럽트에 대응하여 특정 기능을 처리하는 기계어 코드 루틴


> `문맥교환`이 아닌 경우에도 오버헤드가 있지만 `문맥교환`인 경우에 오버헤드가 훨씬 크다.

![](https://velog.velcdn.com/images/rayung999/post/a887050c-2e31-48e4-8d63-94a689d9f322/image.png)

> - 위는 문맥교환이 일어나지 않은 경우
- 아래는 문맥교환이 일어난 경우

- - - 

## 5. 프로세스를 스케줄링하기 위한 큐

`OS` 는 준비 상태에 있는 프로세스들을 줄 세우기 위해 `준비 큐` _ready queue_ 를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다.

### 장치 큐 _Device Queue_ 
- 특정 자원을 기다리는 프로세스들을 줄 세우기 위한 큐
### 준비 큐 _Ready Queue_
- CPU 할당을 대기 중인 프로세스들을 줄 세우기 위한 큐
### 작업 큐 _Job Queue_
- 시스템 내의 모든 프로세스를 관리하기 위한 큐로, 프로세스 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속한다.

![](https://velog.velcdn.com/images/rayung999/post/6045a4d0-2e8d-49f6-a09f-142a1d6fc70c/image.png)

> 프로세스는 상태 변화에 따라 `준비 큐`와 `장치 큐`를 오가며 실행 되고, `작업 큐`가 가장 넓은 개념이고 `준비 큐`와 `장치 큐`에 있는 프로세스들은 모두 `작업 큐`에 속해 있다.

- - - 

## 6. 스케줄러 _scheduler_
어떤 프로세스애개 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다.

### 장기 스케줄러_long term scheduler_
- `작업 스케줄러`_job scheduler_라고도 부르며, 어떤 프로세스를 `준비 큐`에 진입시킬지 결정하는 역할

- 메모리에 동시에 올라가 있는 프로세스의 수 _degree of multiprogramming_을 조절하는 역할

### 단기 스케줄러_short term scheduler_
- `CPU 스케줄러` _CPU scheduler_라고도 하며, 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정하게 된다.

- 빈번하게 호출되기 때문에 수행 속도가 빨라야 한다.

### 중기 스케줄러_medium term scheduler_
- 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 것을 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러

- 프로세스당 보유 메모리양이 지나치게 적어진 경우 이를 완화시키기 위해 일부 프로세스를 메모리에서 디스크로 `스왑 아웃`시키는 역할 수행
	
    - `스왑 아웃` _swap out_ : 시스템의 성능이 저하되기 전에 메모리에 올라와 있는 프로세스 중 일부를 선정해 메모리를 통째로 빼앗아 그 내용을 디스크의 `스왑 영역`에 저장해두는 것.
    
![](https://velog.velcdn.com/images/rayung999/post/48bc8d4b-c5b5-45a9-bca3-de467b4537cd/image.png)

- - - 

## 7. 프로세스의 생성
최초의 프로세스는 운영체제가 직접 생성하지만 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다.
- `부모 프로세스` : 프로세스를 생성한 프로세스
- `자식 프로세스` : 생성된 프로세스
![](https://velog.velcdn.com/images/rayung999/post/4c474211-869a-4e2c-b5ea-25efedd83a52/image.png)

- 프로세스는 `부모 프로세스`가 `자식 프로세스`를 생성하는 방식이다. 
    
- 프로세스는 PCB에 저장된 __PID__ _process identifier_ 값을 통해서 식별되고 관리된다.
- 프로세스는 자원이 필요한데, 자원은 운영체제로부터 받거나 부모와 공유한다. 

### 자원 공유 _Resource sharing option_
- 부모와 자식이 모든 자원을 `공유`하는 모델
- 부모와 자식이 자원의 일부를 공유하는 모델
- 전혀 공유하지 않는 모델

### 수행 _Execution_
- 부모와 자식이 공존하며 `동시 수행`돠는 모델
- 자식이 종료될 때까지 부모가 기다리는 모델

### 주소 공간 _Address space_
- 자식이 부모의 공간을 `복제`하는 모델
- 자식이 해당 공간에 새로운 프로그램을 올리는 모델
 
> 이와 같이 프로세스는 각 특성마다 이 세가지로 분류된다.

### 프로세스의 종료
#### 자발적 종료
프로세스가 마지막 명령을 수행한 후 os에게 이를 알려 이루어짐.
- 프로세스는 `명령` _instruction_ 을 모두 수행한 후, 프로그램이 마쳐지는 코드 부분에 `exit()`라는 시스템 콜을 넣어주도록 되어 있다.
- 시스템 콜을 통해 자신이 종료됨을 알림
- 종료를 통보받은 os는 이 프로세스로부터 자원을 회수하고 시스템 내에서 이 프로세스를 정리
> `exit() 함수`는 프로그램 개발자가 명시적으로 호출하지 않아도 프로그램이 종료되는 지점에 컴파일러가 자동으로 삽입해 프로세스의 `종료 직전`에 항상 호출된다.

#### 비자발적 종료
부모 프로세스가 자식 프로세스의 수행을 `강제 종료` 시키는 것.
- 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양을 요구할 때
- 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
- 부모 프로세스가 종료되는 경우 -> 단계적인 종료 발생

> 자식 프로세스는 부모 프로세스의 처움부터 수행을 시작하는 것이 아니라 부모 프로세스가 현재 수행한 시점(프로그램 카운터 지점)부터 수행하게 된다.

> 다만, os가 프로세스를 관리하기 위해서 사용하는 프로세스 식별자는 부모 프로세스와 다른 식별자를 가지게 된다는 점이 유일한 차이점.

- - -

## 8. 프로세스간의 협력
프로세스간의 협력 메커니즘을 위해 운영체제가 제공하는 대표적인 메커니즘으로는
`IPC` _Inter-Process Communication_가 있다.

### IPC 
- 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신
- 프로세스들 간의 `통신` _communication_ 과 `동기화`를 이루기 위한 메커니즘을 의미

<br>

#### 1) 메시지 전달 방식 _message passing_
프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고 받으면서 통신하는 방식
- 메시지 직접 전달 불가해 `커널`이 그 역할을 함
- 커널에 의해 send와 receive 두 가지 연산을 제공 받게 됨
	
    - 이 두 연산을 통해 운영체제에게 시스템 콜 방식으로 요청해 전달
    
<br>    

- `직접 통신` _direct communication_

 	
    - 통신하려는 프로세스의 이름을 명시적으로 표시
	
    - `send` ( `P`, message ) 는 프로세스 `P`에게 메시지를 전송
	
    - `receive` ( `Q`, message ) 는 프로세스 `Q`로부터 메시지를 전달 받는 것
	
    - 링크는 자동적으로 생성
	
    - 하나의 링크는 정확히 한 쌍의 프로세스에게 할당
	
    - 각 쌍의 프로세스에는 오직 하나의 링크만이 존재
	
    - 링크는 `단방향성`_unidirectional_일 수 있으나 대부분 `양방향성` _bidirectioal_
    
    
- `간접 통신` _indirect communication_
   
   - `메일박스` 또는 `포트`로부터 전달
   - 각 메일박스에는 `고유의 ID`가 있으며 메일박스를 공유하는 프로세스들만 서로 통신 가능
   - 간접통신에서 사용되는 `커뮤니케이션 링크`는 프로세스 간에 메일박스를 공유하는 경우에만 생성
   - 하나의 링크가 여러 프로세스들에게 할당될 수 있으며 여러 링크가 공유 가능
   - 링크는 `단방향성`이나 `양방향성`일 수 있음
   	<br>
     - 새로운 메일박스를 `생성`하는 연산
     - 메일박스를 통한 메시지의 `send()` / `recieve()` 연산
     - 메일박스를 `삭제`하는 연산 등이 사용 가능
  
>이 두 가지 방식의 차이는 연산 인터페이스에 대한 차이일 뿐 실제 메시지 전송이 이루어지는 내부 구현은 동일한 방식으로 이루어진다.

![](https://velog.velcdn.com/images/rayung999/post/585ad79b-5753-4675-a488-a65a4343c808/image.png)

#### 2) 공유 메모리 방식 _shared memory_
프로세스들이 주소 공간의 일부를 공유

- 여러 프로세스가 읽고 쓰는 것이 가능

- 프로세스 A, B가 독자적인 주소 공간을 가지고 있지만 이 주소 공간이 물리적 메모리에 `매핑`될 때 공유메모리 주소 영역에 대해서는 동일한 물리적 메모리 주소로 `매핑`
- 통신을 수월하게 만드는 `인터페이스`를 제공
- 커널이 책임지지 않기에 프로세스들끼리 직접 공유메모리 접근에 대한 동기화 문제를 책임져야 함

![](https://velog.velcdn.com/images/rayung999/post/1a82e045-2a94-4867-af33-6878c7eea959/image.png)


> IPC의 대표적인 방법으로는 두 가지 방식이 있는데 두 방식의 차이점은 프로세스 사이에 
`공유 데이터`_shared data_를 사용하는가, 그렇지 않은가에 있다.